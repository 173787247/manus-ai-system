# 智能体设计

## 1. 智能体架构概述

Manus AI 系统采用多智能体协作架构，每个智能体专注于特定领域，通过协作完成复杂任务。

### 1.1 智能体类型

1. **规划智能体 (Planning Agent)**: 任务分解与执行规划
2. **知识检索智能体 (Knowledge Agent)**: 多源知识检索与融合
3. **代码生成智能体 (Code Agent)**: 动态代码生成与执行
4. **GUI操作智能体 (GUI Agent)**: 屏幕观察与界面操作
5. **评估智能体 (Evaluation Agent)**: 任务完成度评估与反馈

### 1.2 智能体协作模式

```
用户任务
  ↓
规划智能体 (任务分解)
  ├─→ 知识智能体 (检索相关知识)
  ├─→ 代码智能体 (生成执行代码)
  └─→ GUI智能体 (执行界面操作)
  ↓
评估智能体 (评估执行结果)
  ↓
反馈与优化
```

## 2. 基础智能体类 (Base Agent)

所有智能体继承自基础智能体类，提供统一接口和通用功能。

### 2.1 基础接口

```python
class BaseAgent:
    """基础智能体类"""
    
    def __init__(self, name: str, config: dict):
        self.name = name
        self.config = config
        self.state = "idle"  # idle, working, error
        self.memory = []  # 对话历史
        
    def process(self, input_data: dict) -> dict:
        """处理输入，返回结果"""
        raise NotImplementedError
        
    def reset(self):
        """重置智能体状态"""
        self.state = "idle"
        self.memory = []
        
    def get_status(self) -> dict:
        """获取智能体状态"""
        return {
            "name": self.name,
            "state": self.state,
            "memory_length": len(self.memory)
        }
```

### 2.2 通信机制

智能体通过消息总线进行通信：

```python
class MessageBus:
    """消息总线"""
    
    def publish(self, topic: str, message: dict):
        """发布消息"""
        pass
        
    def subscribe(self, topic: str, callback: callable):
        """订阅消息"""
        pass
```

## 3. 规划智能体 (Planning Agent)

### 3.1 功能描述

规划智能体负责：
- 理解用户任务意图
- 将复杂任务分解为子任务
- 规划执行顺序和依赖关系
- 动态调整执行计划

### 3.2 核心能力

1. **任务理解**: 使用LLM理解自然语言任务
2. **任务分解**: 将任务分解为可执行的步骤
3. **依赖分析**: 分析步骤间的依赖关系
4. **执行规划**: 生成最优执行序列
5. **动态调整**: 根据执行情况调整计划

### 3.3 实现设计

```python
class PlanningAgent(BaseAgent):
    """规划智能体"""
    
    def __init__(self, config: dict):
        super().__init__("PlanningAgent", config)
        self.llm = self._init_llm()
        self.decomposition_prompt = self._load_prompt("decomposition")
        
    def decompose_task(self, task: dict) -> dict:
        """分解任务"""
        # 1. 理解任务
        task_understanding = self._understand_task(task)
        
        # 2. 分解为子任务
        subtasks = self._decompose(task_understanding)
        
        # 3. 分析依赖
        dependencies = self._analyze_dependencies(subtasks)
        
        # 4. 生成执行计划
        plan = self._generate_plan(subtasks, dependencies)
        
        return plan
        
    def _understand_task(self, task: dict) -> dict:
        """理解任务意图"""
        prompt = f"""
        分析以下任务，提取关键信息：
        任务: {task['instruction']}
        
        请提取：
        1. 任务目标
        2. 所需资源
        3. 预期结果
        """
        response = self.llm.generate(prompt)
        return self._parse_understanding(response)
        
    def _decompose(self, task_understanding: dict) -> list:
        """分解任务为子任务"""
        prompt = f"""
        将以下任务分解为可执行的子任务：
        {task_understanding}
        
        每个子任务应该：
        1. 具体可执行
        2. 有明确的输入输出
        3. 可以独立验证
        """
        response = self.llm.generate(prompt)
        return self._parse_subtasks(response)
        
    def adjust_plan(self, plan: dict, execution_result: dict) -> dict:
        """根据执行结果调整计划"""
        # 分析执行结果
        # 更新计划
        # 返回调整后的计划
        pass
```

### 3.4 任务分解示例

输入任务：
```
"打开浏览器，搜索'AI Agent'，截图保存，并生成一份报告"
```

分解结果：
```json
{
  "subtasks": [
    {
      "id": "task_1",
      "description": "打开浏览器",
      "type": "gui_action",
      "dependencies": []
    },
    {
      "id": "task_2",
      "description": "在搜索框输入'AI Agent'并搜索",
      "type": "gui_action",
      "dependencies": ["task_1"]
    },
    {
      "id": "task_3",
      "description": "截图保存搜索结果页面",
      "type": "gui_action",
      "dependencies": ["task_2"]
    },
    {
      "id": "task_4",
      "description": "基于搜索结果生成报告",
      "type": "code_generation",
      "dependencies": ["task_3"]
    }
  ],
  "execution_order": ["task_1", "task_2", "task_3", "task_4"]
}
```

## 4. 知识检索智能体 (Knowledge Agent)

### 4.1 功能描述

知识检索智能体负责：
- 多源知识检索（文档、代码、知识图谱）
- 知识融合与排序
- 上下文构建
- 知识更新

### 4.2 核心能力

1. **多源检索**: 向量检索 + 关键词检索 + 图谱查询
2. **知识融合**: 合并多源检索结果
3. **相关性排序**: 基于相关性排序
4. **上下文构建**: 构建适合LLM的上下文

### 4.3 实现设计

```python
class KnowledgeAgent(BaseAgent):
    """知识检索智能体"""
    
    def __init__(self, config: dict):
        super().__init__("KnowledgeAgent", config)
        self.vector_store = VectorStore(config['vector_store'])
        self.knowledge_graph = KnowledgeGraph(config['kg'])
        self.document_store = DocumentStore(config['documents'])
        
    def retrieve(self, query: str, top_k: int = 5) -> list:
        """检索知识"""
        # 1. 向量检索
        vector_results = self.vector_store.search(query, top_k)
        
        # 2. 关键词检索
        keyword_results = self.document_store.search(query, top_k)
        
        # 3. 知识图谱查询
        kg_results = self.knowledge_graph.query(query)
        
        # 4. 结果融合与排序
        merged_results = self._merge_results(
            vector_results, keyword_results, kg_results
        )
        
        return merged_results[:top_k]
        
    def _merge_results(self, *results) -> list:
        """融合多源检索结果"""
        # 去重
        # 排序
        # 返回
        pass
        
    def build_context(self, query: str, retrieved_knowledge: list) -> str:
        """构建上下文"""
        context = f"查询: {query}\n\n相关知识:\n"
        for i, knowledge in enumerate(retrieved_knowledge, 1):
            context += f"{i}. {knowledge['content']}\n"
        return context
```

## 5. 代码生成智能体 (Code Agent)

### 5.1 功能描述

代码生成智能体负责：
- 根据任务生成执行代码
- 代码验证与优化
- 代码执行与结果返回
- 错误处理与修复

### 5.2 核心能力

1. **代码生成**: 基于任务描述生成Python代码
2. **代码验证**: 语法检查和逻辑验证
3. **安全执行**: 在沙箱环境中执行代码
4. **错误修复**: 自动修复常见错误

### 5.3 实现设计

```python
class CodeAgent(BaseAgent):
    """代码生成智能体"""
    
    def __init__(self, config: dict):
        super().__init__("CodeAgent", config)
        self.llm = self._init_llm()
        self.sandbox = CodeSandbox(config['sandbox'])
        
    def generate_code(self, task: dict, context: str) -> str:
        """生成代码"""
        prompt = f"""
        根据以下任务和上下文，生成Python代码：
        
        任务: {task['description']}
        上下文: {context}
        
        要求：
        1. 代码要完整可执行
        2. 包含必要的错误处理
        3. 返回结果要明确
        """
        code = self.llm.generate(prompt)
        return self._extract_code(code)
        
    def execute_code(self, code: str) -> dict:
        """执行代码"""
        try:
            # 代码验证
            self._validate_code(code)
            
            # 在沙箱中执行
            result = self.sandbox.execute(code)
            
            return {
                "status": "success",
                "result": result,
                "output": result.get("output", "")
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "suggestion": self._suggest_fix(code, e)
            }
            
    def _validate_code(self, code: str):
        """验证代码"""
        # 语法检查
        # 安全检查
        # 依赖检查
        pass
```

## 6. GUI操作智能体 (GUI Agent)

### 6.1 功能描述

GUI操作智能体负责：
- 屏幕截图捕获与理解
- 界面元素识别
- 动作生成与执行
- 执行结果验证

### 6.2 核心能力

1. **视觉理解**: 使用VL模型理解屏幕内容
2. **动作生成**: 生成PyAutoGUI操作指令
3. **动作执行**: 执行鼠标键盘操作
4. **结果验证**: 验证操作是否成功

### 6.3 实现设计

```python
class GUIAgent(BaseAgent):
    """GUI操作智能体"""
    
    def __init__(self, config: dict):
        super().__init__("GUIAgent", config)
        self.env = DesktopEnv(config['desktop_env'])
        self.vl_model = self._init_vl_model()
        self.action_parser = ActionParser()
        
    def observe(self) -> dict:
        """观察屏幕"""
        obs = self.env.get_observation()
        return {
            "screenshot": obs['screenshot'],
            "accessibility_tree": obs.get('accessibility_tree'),
            "terminal": obs.get('terminal')
        }
        
    def think(self, observation: dict, task: str) -> dict:
        """思考下一步动作"""
        # 编码截图
        screenshot_b64 = self._encode_screenshot(observation['screenshot'])
        
        # 调用VL模型
        response = self.vl_model.predict(
            task_instruction=task,
            screenshot=screenshot_b64
        )
        
        return response
        
    def act(self, action: str) -> dict:
        """执行动作"""
        # 解析动作
        parsed_actions = self.action_parser.parse(action)
        
        # 执行动作
        results = []
        for action_cmd in parsed_actions:
            if action_cmd in ["DONE", "FAIL"]:
                return {"status": action_cmd}
                
            result = self.env.step(action_cmd, pause=1.0)
            results.append(result)
            
        return {
            "status": "success",
            "results": results,
            "new_observation": results[-1]['obs'] if results else None
        }
        
    def execute_task(self, task: dict) -> dict:
        """执行完整任务"""
        # 重置环境
        obs = self.env.reset(task_config=task)
        
        max_steps = task.get('max_steps', 10)
        for step in range(max_steps):
            # 观察
            observation = self.observe()
            
            # 思考
            response, actions = self.think(observation, task['instruction'])
            
            # 行动
            result = self.act(actions)
            
            if result['status'] in ["DONE", "FAIL"]:
                break
                
            # 更新观察
            obs = result.get('new_observation', observation)
            
        return {
            "status": result['status'],
            "steps": step + 1,
            "final_observation": obs
        }
```

### 6.4 动作解析器

```python
class ActionParser:
    """动作解析器"""
    
    def parse(self, model_output: str) -> list:
        """从模型输出解析动作"""
        actions = []
        
        # 1. 提取代码块
        code_blocks = self._extract_code_blocks(model_output)
        
        # 2. 提取PyAutoGUI命令
        for block in code_blocks:
            pyautogui_commands = self._extract_pyautogui_commands(block)
            actions.extend(pyautogui_commands)
            
        # 3. 提取控制符
        control_chars = self._extract_control_chars(model_output)
        actions.extend(control_chars)
        
        # 4. 验证与过滤
        actions = self._validate_actions(actions)
        
        return actions if actions else ["FAIL"]
        
    def _extract_pyautogui_commands(self, code: str) -> list:
        """提取PyAutoGUI命令"""
        import re
        pattern = r'pyautogui\.\w+\([^)]*\)'
        matches = re.findall(pattern, code)
        return matches
        
    def _validate_actions(self, actions: list) -> list:
        """验证动作"""
        validated = []
        for action in actions:
            # 白名单检查
            if not self._is_whitelisted(action):
                continue
            # 坐标检查
            if not self._validate_coordinates(action):
                continue
            validated.append(action)
        return validated
```

## 7. 评估智能体 (Evaluation Agent)

### 7.1 功能描述

评估智能体负责：
- 任务完成度评估
- 执行质量评估
- 提供改进建议
- 生成评估报告

### 7.2 核心能力

1. **完成度评估**: 检查任务是否完成
2. **质量评估**: 评估执行质量
3. **问题识别**: 识别执行中的问题
4. **建议生成**: 生成改进建议

### 7.3 实现设计

```python
class EvaluationAgent(BaseAgent):
    """评估智能体"""
    
    def __init__(self, config: dict):
        super().__init__("EvaluationAgent", config)
        self.llm = self._init_llm()
        
    def evaluate(self, task: dict, execution_result: dict) -> dict:
        """评估任务执行结果"""
        # 1. 完成度评估
        completion = self._evaluate_completion(task, execution_result)
        
        # 2. 质量评估
        quality = self._evaluate_quality(execution_result)
        
        # 3. 问题识别
        issues = self._identify_issues(execution_result)
        
        # 4. 建议生成
        suggestions = self._generate_suggestions(issues)
        
        return {
            "completion_score": completion,
            "quality_score": quality,
            "issues": issues,
            "suggestions": suggestions,
            "overall_status": "success" if completion > 0.8 else "partial"
        }
        
    def _evaluate_completion(self, task: dict, result: dict) -> float:
        """评估完成度"""
        evaluator = task.get('evaluator')
        if not evaluator:
            return 0.5  # 默认值
            
        # 根据评估器类型执行评估
        if evaluator['type'] == 'screenshot_check':
            return self._check_screenshot(result, evaluator)
        elif evaluator['type'] == 'vm_command_line':
            return self._check_command_output(result, evaluator)
        else:
            return 0.5
```

## 8. 智能体协作流程

### 8.1 典型协作流程

```
1. 用户提交任务
   ↓
2. 规划智能体分解任务
   ├─→ 需要知识 → 知识智能体检索
   ├─→ 需要代码 → 代码智能体生成
   └─→ 需要GUI操作 → GUI智能体执行
   ↓
3. 执行引擎协调执行
   ↓
4. 评估智能体评估结果
   ↓
5. 返回结果给用户
```

### 8.2 通信协议

智能体间通过消息总线通信：

```python
# 任务请求消息
{
    "type": "task_request",
    "from": "PlanningAgent",
    "to": "KnowledgeAgent",
    "payload": {
        "query": "AI Agent相关知识",
        "top_k": 5
    }
}

# 任务响应消息
{
    "type": "task_response",
    "from": "KnowledgeAgent",
    "to": "PlanningAgent",
    "payload": {
        "results": [...],
        "status": "success"
    }
}
```

## 9. 智能体状态管理

每个智能体维护自己的状态：

```python
{
    "state": "idle" | "working" | "error",
    "current_task": {...},
    "memory": [...],
    "statistics": {
        "tasks_completed": 0,
        "tasks_failed": 0,
        "average_time": 0
    }
}
```

## 10. 扩展性设计

### 10.1 新增智能体

1. 继承 `BaseAgent`
2. 实现 `process` 方法
3. 注册到智能体管理器
4. 配置通信路由

### 10.2 智能体插件化

支持通过配置文件动态加载智能体：

```yaml
agents:
  - name: CustomAgent
    class: custom_module.CustomAgent
    config:
      param1: value1
```

